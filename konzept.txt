///User Registration
1. User can choose "Username" and "Password" (with restrictions like minimum length of 8)
2. Generate automatically RSA Public Key ("UserPubKey") and Private Key ("UserPrivKey") --- KeyPairGenerator("RSA")
3. Store the "UserPubKey" in the public storage of the keychain ("KeychainUserPubKey")
4. Store the "Username" in the public storage of the keychain ("KeychainUsername")
5. Generate SHA1-Hash from Username and Password ("HashUsernamePassword")
6. Use the first 16 Bytes (= 128 bits) from "HashUsernamePassword" to encrypt "UserPrivKey" with AES (results in "EncryptedUserPrivKey")
7. Store the "EncryptedUserPrivKey" in the public storage of the keychain ("KeychainEncryptedUserPrivKey")
---
8. Do the necessary stuff to store the whole User in the keyfile

///Login
1. User has to pass "Username" and "Password"
2. The system checks in his keyfile if any keychain has a "KeychainUsername" called "Username"
	2a. Not found: Error message "Username OR Password wrong" and stop
3. Generate SHA1-Hash from Username and Password ("HashUsernamePassword")
4. Use the first 16 Bytes (= 128 bits) from "HashUsernamePassword" to decrypt "KeychainEncryptedUserPrivKey" (results in "UserPrivKey")
5. Generate random string ("RandomTestString") and encrypt it with the "KeychainUserPubKey" (results in "EncryptedRandomTestString")
6. Decrypt the "EncryptedRandomTestString" with the "UserPrivKey"
	6a. "EncryptedRandomTestString" does not equal "RandomTestString": Error message "Username OR Password wrong" and stop
---
7. Status: Logged in

///Container Usage - Open
Prerequisites: User has to be logged in
1. User selects with a dialog box the path of the container - maybe prefilter with *.crypt
2. Read the first 64 Byte (512 Bit) as "ContainerKeyHash"
3. Search for an AES key in your keychain, which SHA512 hash results in "ContainerKeyHash"
	3a. Not found: Error message "You have no key to open this Container" and stop
	3b. You get a pointer/reference to the AES key which opens the Container ("ContainerKey")
4. Read the next 4 Byte (32 Bit) as "HeaderLength"
---
Annotation: This design results in the rule, that the first 68 Bytes are not encrypted
---
5. Read the next "HeaderLength" Byte as "EncryptedHeader"
6. Decrypt the "EncryptedHeader" with the "ContainerKey" as "Header"
7. Deserialize the "Header" to an Object, in which you get the Filenames, their absolute position and length in the Container
---
8. Status: Container is opened
---
Annotation: Do we need Lockfiles to disallow multiple writers?
